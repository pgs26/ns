# -*- coding: utf-8 -*-
"""NS Lab.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B_Vl1XMaWuJE9ZXcTSY3zdPxpdp-8t1j
"""
import networkx as nx
import matplotlib.pyplot as plt
import random

def erdos_renyi_graph(N, p):
    G = nx.Graph()
    G.add_nodes_from(range(N))
    for i in range(N):
        for j in range(i + 1, N):
            if random.random() < p:
                G.add_edge(i, j)
    return G
N = 20
p = 0.1
G = erdos_renyi_graph(N, p)

plt.figure(figsize=(6, 6))
nx.draw(G, node_size=200, with_labels=True)
plt.title(f"Erdős–Rényi G({N}, {p}) Random Graph")
plt.show()

"""## Track Larget component ER"""
# Parameters
N = 500       # number of nodes
avg_k = 4     # average degree
p = avg_k / (N - 1)

# Generate ER network
G = nx.erdos_renyi_graph(N, p)

# Track largest component size
largest_component_sizes = []
fraction_removed = []

# Create a list of nodes to remove
nodes = list(G.nodes())
random.shuffle(nodes)

for i, node in enumerate(nodes):
    # Remove the node
    G.remove_node(node)

    # Compute size of largest connected component
    if len(G) > 0:
        largest_cc = max(nx.connected_components(G), key=len)
        largest_component_sizes.append(len(largest_cc))
    else:
        largest_component_sizes.append(0)

    fraction_removed.append((i + 1) / N)

# Plot the results
plt.figure(figsize=(8,5))
plt.plot(fraction_removed, largest_component_sizes, marker='o', linestyle='-', color='red')
plt.xlabel("Fraction of nodes removed")
plt.ylabel("Size of largest connected component")
plt.title("Robustness of ER Network under Random Node Failures")
plt.grid(True)
plt.show()

"""## All metrics"""

import networkx as nx
import matplotlib.pyplot as plt
import collections
from networkx.algorithms import community

# Load GML file
G = nx.read_gml("network.gml")

# 1. Basic properties
N = G.number_of_nodes()
L = G.number_of_edges()
avg_degree = sum(dict(G.degree()).values()) / N
print(f"Nodes: {N}, Edges: {L}, Avg degree: {avg_degree:.2f}")

# 2. Connectivity
components = sorted(nx.connected_components(G), key=len, reverse=True)
GCC = G.subgraph(components[0])
print(f"Connected components: {len(components)}")
print(f"GCC size: {GCC.number_of_nodes()} nodes")

# 3. Path stats
avg_path = nx.average_shortest_path_length(GCC)
diameter = nx.diameter(GCC)
print(f"Avg path length: {avg_path:.2f}, Diameter: {diameter}")

# 4. Clustering
clustering = nx.average_clustering(G)
print(f"Avg clustering coefficient: {clustering:.3f}")

# 5. Centralities
deg_cent = nx.degree_centrality(G)
bet_cent = nx.betweenness_centrality(G)
close_cent = nx.closeness_centrality(G)
eig_cent = nx.eigenvector_centrality(G)

# Show top nodes by degree
sorted_deg = sorted(deg_cent.items(), key=lambda x: x[1], reverse=True)[:5]
print("Top 5 nodes by degree centrality:", sorted_deg)

# 6. Community detection (Louvain if available, else greedy modularity)
communities = community.greedy_modularity_communities(G)
print(f"Detected {len(communities)} communities")

# 7. Degree distribution
degrees = [d for n, d in G.degree()]
degree_count = collections.Counter(degrees)
deg, cnt = zip(*sorted(degree_count.items()))

plt.figure(figsize=(6,4))
plt.loglog(deg, cnt, "bo")
plt.xlabel("Degree k")
plt.ylabel("Count")
plt.title("Degree distribution (log-log)")
plt.show()

# 8. Network visualization
plt.figure(figsize=(8,8))
pos = nx.spring_layout(G, seed=42)
nx.draw_networkx_nodes(G, pos, node_size=50, cmap=plt.cm.Set1)
nx.draw_networkx_edges(G, pos, alpha=0.3)
plt.title("Network Visualization")
plt.show()

import networkx as nx
import matplotlib.pyplot as plt
import collections
import numpy as np
from networkx.algorithms import community

# Load network
G = nx.read_gml("network.gml")

# Ensure largest connected component for path-based metrics
components = sorted(nx.connected_components(G), key=len, reverse=True)
GCC = G.subgraph(components[0]).copy()

# Degree distribution
degrees = [d for n, d in G.degree()]
deg_count = collections.Counter(degrees)
deg, cnt = zip(*sorted(deg_count.items()))

plt.figure(figsize=(6,4))
plt.bar(deg, cnt)
plt.title("Degree Distribution")
plt.xlabel("Degree k")
plt.ylabel("Count")
plt.show()

plt.figure(figsize=(6,4))
plt.loglog(deg, cnt, "bo")
plt.title("Degree Distribution (Log-Log)")
plt.xlabel("Degree k")
plt.ylabel("Count")
plt.show()

# Cumulative degree distribution
sorted_deg = sorted(degrees)
cdf = np.arange(len(sorted_deg))/len(sorted_deg)
plt.figure(figsize=(6,4))
plt.plot(sorted_deg, 1-cdf)
plt.yscale("log")
plt.xscale("log")
plt.xlabel("Degree k")
plt.ylabel("CCDF")
plt.title("Cumulative Degree Distribution")
plt.show()

# Shortest path length distribution
lengths = dict(nx.all_pairs_shortest_path_length(GCC))
all_lengths = [l for d in lengths.values() for l in d.values()]
plt.hist(all_lengths, bins=30)
plt.title("Shortest Path Length Distribution")
plt.xlabel("Path length")
plt.ylabel("Frequency")
plt.show()

# Clustering coefficient histogram
clust = nx.clustering(G)
plt.hist(clust.values(), bins=20)
plt.title("Local Clustering Coefficients")
plt.xlabel("C")
plt.ylabel("Count")
plt.show()

# Clustering vs degree
plt.scatter(degrees, list(clust.values()), alpha=0.5)
plt.xscale("log")
plt.title("Clustering vs Degree")
plt.xlabel("Degree k")
plt.ylabel("Clustering C")
plt.show()

# Centrality histograms
centralities = {
    "Degree Centrality": nx.degree_centrality(G),
    "Betweenness": nx.betweenness_centrality(G),
    "Closeness": nx.closeness_centrality(G),
    "Eigenvector": nx.eigenvector_centrality(G, max_iter=500),
}

for name, cent in centralities.items():
    plt.hist(cent.values(), bins=30)
    plt.title(f"{name} Distribution")
    plt.show()

# Communities
communities = community.greedy_modularity_communities(G)
sizes = [len(c) for c in communities]
plt.hist(sizes, bins=20)
plt.title("Community Size Distribution")
plt.xlabel("Size")
plt.ylabel("Count")
plt.show()

# Assortativity: average neighbor degree vs node degree
avg_nbr_deg = nx.average_neighbor_degree(G)
plt.scatter(degrees, list(avg_nbr_deg.values()), alpha=0.5)
plt.xscale("log")
plt.yscale("log")
plt.xlabel("Node degree k")
plt.ylabel("Average neighbor degree")
plt.title("Degree-Degree Correlation")
plt.show()

# Network visualizations
plt.figure(figsize=(8,8))
pos = nx.spring_layout(G, seed=42)
nx.draw(G, pos, node_size=30, node_color="blue", edge_color="gray", alpha=0.6)
plt.title("Network Visualization (Spring Layout)")
plt.show()

plt.figure(figsize=(8,8))
nx.draw_circular(G, node_size=30, alpha=0.6)
plt.title("Network Visualization (Circular Layout)")
plt.show()

plt.figure(figsize=(8,8))
nx.draw_shell(G, node_size=30, alpha=0.6)
plt.title("Network Visualization (Shell Layout)")
plt.show()
